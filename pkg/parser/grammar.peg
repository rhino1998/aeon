{
  package parser

  import "log"

  func anyToSlice[T any](s any) []T {
    var ret []T
    for _, e := range s.([]any) {
      if e == nil {
        continue
      }
      ret = append(ret, e.(T))
    }

    return ret
  }

  func toPtr[T any](v T) *T {
    return &v
  }

  func maybe[T any](v any) T {
    if v == nil {
      var t T
      return t
    }

    return v.(T)
  }

  func maybePtr[T any](v any) *T {
    if v == nil {
      return nil
    }

    return toPtr(v.(T))
  }

  func maybeSlice[T any](v any) []T {
    if v == nil {
      return nil
    }

    return v.([]T)
  }
}

File <- pkg:Package __ decls:(Declaration)* EOF {
  return File {
    Package: pkg.(Package),

    Declarations: anyToSlice[Declaration](decls),
  }, nil
}

Keyword <- "map" / "func" / "if" / "else" / "for" / "package" / "var" / "extern" / "const"

Package <- "package" _ name:Identifier {
  return Package{
    Name: name.(Identifier),
  }, nil
}

Declaration <- _ decl:(Directive / FunctionDeclaration / ExternFuncDeclaration / TypeDeclaration / VarDeclaration / ConstDeclaration) __ {
  return decl, nil
}

Directive <- '#' name:Identifier _ args:DirectiveArguments? __ decl:Declaration {
	return Directive{
		Name: name.(Identifier),
		Args: maybeSlice[any](args),
		Declaration: decl.(Declaration),

    Position: pos(c),
	}, nil
}

DirectiveArguments <- arg:DirectiveArgument rest:DirectiveArgumentsRest? {
	return append(append([]any{}, arg), maybeSlice[any](rest)...), nil
}

DirectiveArgumentsRest <- _ args:DirectiveArguments {
	return args, nil
}

DirectiveArgument <- Identifier / StringLiteral / FloatLiteral / IntLiteral / BoolLiteral

TypeDeclaration <- "type" _ name:Identifier _ typ:Type {
  return TypeDeclaration{
    Name: name.(Identifier),
    Type: typ.(Type),
  }, nil
}

ConstDeclaration <- "const" _ name:Identifier _ typ:Type? _ exp:VarStatementExpr? {
  if typ == nil && exp == nil {
    return nil, fmt.Errorf("var statement must have a type or an expression")
  }

  return ConstDeclaration{
    Name: name.(Identifier),
    Expr: maybePtr[Expr](exp),
    Type: maybePtr[Type](typ),

    Position: pos(c),
  }, nil
}

Type <- Identifier / PointerType / MapType / SliceType / TupleType

PointerType <- '*' pointee:Type {
  return PointerType{Pointee: pointee.(Type)}, nil
}

SliceType <- '[' _ ']' element:Type {
  return SliceType{Element: element.(Type)}, nil
}

TupleType <- '(' elems:TupleTypeList? ')' {
  return TupleType{Elements: maybeSlice[Type](elems)}, nil
}

TupleTypeList <- _ elem:Type _ rest:TupleTypeListComma? {
  return append([]Type{elem.(Type)}, maybeSlice[Type](rest)...), nil
}

TupleTypeListComma <- ',' rest:TupleTypeList {
  return rest, nil
}

TupleKey <- [0-9]+ {
  return Identifier(c.text), nil
}

MapType <- "map" _ '[' _ key:Type _ ']' _ value:Type {
  return MapType{Key: key.(Type), Value:value.(Type)}, nil
}

Statement <- stmt:(comment / VarStatement / ReturnStatement / DeclarationStatement / AssignmentOperatorStatement / AssignmentStatement / IfStatement / ForStatement / PostfixStatement / ExprStatement) {
  return stmt, nil
}

SimpleStatement <- stmt:(VarStatement / DeclarationStatement / AssignmentOperatorStatement / AssignmentStatement / PostfixStatement / ExprStatement) {
  return stmt, nil
}

VarStatement <- "var" _ name:Identifier _ typ:Type? _ exp:VarStatementExpr? {
  if typ == nil && exp == nil {
    return nil, fmt.Errorf("var statement must have a type or an expression")
  }

  return &VarStatement{
    Name: name.(Identifier),
    Expr: maybePtr[Expr](exp),
    Type: maybePtr[Type](typ),

    Position: pos(c),
  }, nil
}

VarStatementExpr <- '=' _ exp:Expr _ {
  return exp.(Expr), nil
}

VarDeclaration <- "var" _ name:Identifier _ typ:Type? _ exp:VarDeclarationExpr? {
  if typ == nil && exp == nil {
    return nil, fmt.Errorf("var statement must have a type or an expression")
  }

  return VarDeclaration{
    Name: name.(Identifier),
    Expr: maybePtr[Expr](exp),
    Type: maybePtr[Type](typ),

    Position: pos(c),
  }, nil
}

VarDeclarationExpr <- '=' _ exp:Expr _ {
  return exp.(Expr), nil
}

DeclarationStatement <- ident:Identifier _ ":=" _ exp:Expr {
  return DeclarationStatement{
    Name:ident.(Identifier),
    Expr:exp.(Expr),

    Position: pos(c),
  }, nil
}

AssignmentStatement <- left:Expr _ '=' _ right:Expr {
  return AssignmentStatement{
    Left:left.(Expr),
    Right:right.(Expr),

    Position: pos(c),
  }, nil
}

AssignmentOperatorStatement <- left:Expr _ op:("+=" / "-=" / "*=" / "/=" / "%=" / "**=") _ right:Expr {
  return AssignmentOperatorStatement{
    Left:left.(Expr),
    Operator:Operator(op.([]byte)),
    Right:right.(Expr),

    Position: pos(c),
  }, nil
}

ExprStatement <- exp:Expr {
  return ExprStatement{
    Expr: exp.(Expr),

    Position: pos(c),
  }, nil
}

PostfixStatement <- exp:Expr _ op:("++" / "--") {
  return PostfixStatement{
    Expr: exp.(Expr),
    Operator: Operator(op.([]byte)),

    Position: pos(c),
  }, nil
}

IfStatement <- "if" _ exp:Expr _ '{' body:StatementList? '}' _ rest:(ElseIfStatement / ElseStatement)? {
  return IfStatement{
    Condition: exp.(Expr),
    Body: maybeSlice[Statement](body),
    Else: maybe[ElseIfElseStatement](rest),

    Position: pos(c),
  }, nil
}

ElseIfStatement <- "else" _ "if" _ exp:Expr _ '{' body:StatementList? '}' _ rest:(ElseIfStatement / ElseStatement)? {
  return ElseIfStatement{
    Condition: exp.(Expr),
    Body: maybeSlice[Statement](body),
    Else: maybe[ElseIfElseStatement](rest),

    Position: pos(c),
  }, nil
}

ElseStatement <- "else" _ '{' body:StatementList? _ '}' {
  return ElseStatement{
    Body: maybeSlice[Statement](body),

    Position: pos(c),
  }, nil
}


ForStatement <- "for" _ header:ForStatementStatements? _ '{' __ body:StatementList? '}' {
  if header == nil {
    return ForStatement{
      Body: maybeSlice[Statement](body),

      Position: pos(c),
    }, nil
  }

  f := header.(ForStatement)
  f.Body = maybeSlice[Statement](body)
  f.Position = pos(c)
  return f, nil
}

ForStatementStatements <- init:SimpleStatement? _ ';' _ cond:Expr? _ ';' _ step:SimpleStatement? {
  return ForStatement{
    Init: maybe[Statement](init),
    Condition: maybe[Expr](cond),
    Step: maybe[Statement](step),
  }, nil
}

ReturnStatement <- "return" _ expr:Expr? {
  return ReturnStatement{
    Expr: maybe[Expr](expr),

    Position: pos(c),
  }, nil
}

ExternFuncDeclaration <- "extern" _ "func" _ name:Identifier '(' params:ParameterList? ')' _ ret:Type? _ {
  return ExternFunctionDeclaration{
    Name: name.(Identifier),
    Parameters: maybeSlice[Parameter](params),
    Return: maybe[Type](ret),
  }, nil
}

FunctionDeclaration <- "func" _ name:Identifier '(' params:ParameterList? ')' _ ret:Type? _ '{' body:StatementList? '}' {
  return FunctionDeclaration{
    Name: name.(Identifier),
    Parameters: maybeSlice[Parameter](params),
    Return: maybe[Type](ret),
    Body: maybeSlice[Statement](body),
  }, nil
}

StatementList <- __ stmt:Statement __ rest:StatementList? __ {
  if stmt == nil {
    return rest, nil
  }
  return append(
    []Statement{stmt.(Statement)},
    maybeSlice[Statement](rest)...,
  ), nil
}

Parameter <- ParameterNamed / ParameterUnnamed

ParameterUnnamed <- typ:Type {
  return Parameter{
    Type: typ.(Type),
  }, nil
}

ParameterNamed <- name:Identifier _ typ:Type {
  return Parameter{
    Name: maybePtr[Identifier](name),
    Type: typ.(Type),
  }, nil
}

ParameterList <- _ param:Parameter _ rest:ParameterListComma? {
  return append([]Parameter{param.(Parameter)}, maybeSlice[Parameter](rest)...), nil
}

ParameterListComma <- ',' rest:ParameterList {
  return rest, nil
}

Identifier <- !Keyword [_a-zA-Z][_a-zA-Z0-9]* {
  return Identifier(c.text), nil
}

ParenthesizedExpr <- '(' _ expr:Expr _ ')' {
  return ParenthesizedExpr{
    Expr: expr.(Expr),

    Position: pos(c),
  }, nil
}

IntLiteral <- '-' ? ( [0-9]+ / ("0x" [0-9a-f]+) / ("0o" [0-7]) / ("0b" [0-1])) {
  i, err := strconv.ParseInt(string(c.text), 0, 64)
  if err != nil {
    return 0, err
  }

  return IntLiteral{
    Value: i,

    Position: pos(c),
  }, nil
}

FloatLiteral <- '-' ? ( [0-9]+.[0-9]+) {
  f, err := strconv.ParseFloat(string(c.text), 64)
  if err != nil {
    return 0, err
  }

  return FloatLiteral{
    Value: f,

    Position: pos(c),
  }, nil
}


StringLiteral <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    str, err := strconv.Unquote(string(c.text))
    if err != nil {
      return nil, err
    }

    return StringLiteral{
      Value: str,

      Position: pos(c),
    }, nil
}

BoolLiteral <- ("true" / "false") {
  return BoolLiteral{
    Value: string(c.text)=="true",

    Position: pos(c),
  }, nil
}

IdentifierExpr <- ident:Identifier {
  return IdentifierExpr{
    Identifier: ident.(Identifier),
    Position: pos(c),
  }, nil
}

MaybeCallExpr <- CallExpr / IdentifierExpr

CallExpr <- exp:MaybeCallExpr '(' args:CallArgumentList? ')' {
  call := CallExpr{
    Expr: exp.(Expr),

    Position: pos(c),
  }

  if args != nil {
    call.Args = args.([]Expr)
  }

  return call, nil
}

CallArgumentList <- _ exp:Expr _ rest:CallArgumentListComma? {
  return append([]Expr{exp.(Expr)}, maybeSlice[Expr](rest)...), nil
}

CallArgumentListComma <- ',' rest:CallArgumentList {
  return rest, nil
}

DotExpr <- exp:Expr '.' ident:(Identifier / TupleKey) {
  return DotExpr{
    Expr:exp.(Expr),
    Key:ident.(Identifier),

    Position: pos(c),
  }, nil
}

Expr <- MaybeOrExpr

TermExpr <- UnaryExpr / DotExpr / ParenthesizedExpr / FloatLiteral / IntLiteral / StringLiteral / BoolLiteral / MaybeCallExpr

MaybeExpExpr <- ExpExpr / TermExpr

ExpExpr <- left:TermExpr _ op:("**") _ right:MaybeExpExpr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),

    Position: pos(c),
  }, nil
}

MaybeMulExpr <- MulExpr / MaybeExpExpr

MulExpr <- left:MaybeExpExpr _ op:("*" / "/" / "%" / "<<" / ">>" / "&") _ right:MaybeMulExpr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),

    Position: pos(c),
  }, nil
}

MaybeAddExpr <- AddExpr / MaybeMulExpr

AddExpr <- left:MaybeMulExpr _ op:("+" / "-" / "|" / "^") _ right:MaybeAddExpr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),

    Position: pos(c),
  }, nil
}

MaybeCmpExpr <- CmpExpr / MaybeAddExpr

CmpExpr <- left:MaybeAddExpr _ op:("==" / "!=" / ">=" / "<=" / ">" / "<") _ right:MaybeCmpExpr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),

    Position: pos(c),
  }, nil
}

MaybeAndExpr <- AndExpr / MaybeCmpExpr

AndExpr <- left:MaybeCmpExpr _ op:("&&") _ right:MaybeCmpExpr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),

    Position: pos(c),
  }, nil
}

MaybeOrExpr <- OrExpr / MaybeAndExpr

OrExpr <- left:MaybeAndExpr _ op:("||") _ right:MaybeAndExpr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),

    Position: pos(c),
  }, nil
}

UnaryExpr <- op:("-" / "+" / "!" / "^" / "*" / "&") exp:Expr {
  return UnaryExpr{
    Operator: Operator(op.([]byte)),
    Expr: exp.(Expr),

    Position: pos(c),
  }, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

__ "whitespace" <- [ \n\t\r]*
_ "spaces" <- [ \t]*

comment <- "//" [^\n]* '\n' {
  return nil, nil
}

EOF <- !.
