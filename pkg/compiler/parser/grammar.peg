{
package parser

func anyToSlice[T any](s any) []T {
  var ret []T
  for _, e := range s.([]any) {
    if e == nil {
      continue
    }
    ret = append(ret, e.(T))
  }

  return ret
}

}

Program <- pkg:Package _ decls:(Declaration)* EOF {
  return Program {
    Package: pkg.(Package),

    Declarations: anyToSlice[Declaration](decls),
  }, nil
}

Package <- "package" _ name:Identifier {
  return Package{
    Name: name.(Identifier),
  }, nil
}

Declaration <- FunctionDeclaration

Type <- Identifier / PointerType

PointerType <- '*' pointee:Type {
  return PointerType{Pointee: pointee.(Type)}, nil
}

Statement <- VarStatement / IfStatement / PostfixStatement / ExprStatement

VarStatement <- _ "var" _ name:Identifier _ typ:Type? _ exp:VarStatementExpr? {
  var v VarStatement
  v.Name = name.(Identifier)
  if typ != nil {
    typePtr := typ.(Type)
    v.Type = &typePtr
  }

  if exp != nil {
    expPtr := exp.(Expr)
    v.Expr = &expPtr
  }

  if typ == nil && exp == nil {
    return nil, fmt.Errorf("var statement must have a type or an expression")
  }

  return v, nil
}

VarStatementExpr <- '=' _ exp:Expr _ {
  return exp.(Expr), nil
}

ExprStatement <- _ exp:Expr _ {
  return ExprStatement{Expr: exp.(Expr)}, nil
}

PostfixStatement <- _ exp:Expr op:("++" / "--") _ {
  return PostfixStatement{Expr: exp.(Expr), Operator: Operator(op.([]byte))}, nil
}

IfStatement <- _ "if" _ exp:Expr _ '{' body:(Statement)* _ '}' _ rest:(ElseIfStatement / ElseStatement)? {
  s := IfStatement{
    Condition: exp.(Expr),
    Body: anyToSlice[Statement](body),
  }

  if rest != nil {
    s.Else = rest.(ElseIfElseStatement)
  }

  return s, nil
}

ElseIfStatement <- _ "else" _ "if" _ exp:Expr _ '{' body:(Statement)* _ '}' _ rest:(ElseIfStatement / ElseStatement)? {
  s := ElseIfStatement{
    Condition: exp.(Expr),
    Body: anyToSlice[Statement](body),
  }

  if rest != nil {
    s.Else = rest.(ElseIfElseStatement)
  }

  return s, nil
}

ElseStatement <- _ "else" _ '{' body:(Statement)* _ '}' _ {
  return ElseStatement{
    Body: anyToSlice[Statement](body),
  }, nil
}

FunctionDeclaration <- _ "func" _ name:Identifier '(' params:ParameterList? ')' _ ret:Type? _ '{' body:(Statement)* '}' _ {
  f := FunctionDeclaration{
    Name: name.(Identifier),
    Body: anyToSlice[Statement](body),
  }

  if params != nil {
    f.Parameters = params.([]Parameter)
  }

  if ret != nil {
    retPtr := ret.(Type)
    f.Return = &retPtr
  }

  return f, nil
}

ParameterList <- _ name:Identifier _ typ:Type _ rest:ParameterListComma? {
  p := Parameter {
    Name: name.(Identifier),
    Type: typ.(Type),
  }

  if rest == nil {
    return []Parameter{p}, nil
  }

  return append([]Parameter{p}, rest.([]Parameter)...), nil
}

ParameterListComma <- ',' rest:ParameterList {
  return rest, nil
}

Identifier <- [_a-zA-Z][_a-zA-Z0-9]* {
  return Identifier(c.text), nil
}

Expr <- CallExpr / DotExpr / BinaryExpr / NumberLiteral / StringLiteral / BooleanLiteral / IdentifierExpr

NumberLiteral <- '-' ? ( [0-9]+ / [0-9]+.[0-9]+) {
  f, err := strconv.ParseFloat(string(c.text), 64)
  if err != nil {
    return 0, err
  }

  return NumberLiteral(f), nil
}

StringLiteral <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    str, err := strconv.Unquote(string(c.text))
    if err != nil {
      return nil, err
    }

    return StringLiteral(str), nil
}

BooleanLiteral <- ("true" / "false") {
  return BooleanLiteral(string(c.text)=="true"), nil
}

IdentifierExpr <- ident:Identifier {
  return IdentifierExpr{Identifier: ident.(Identifier)}, nil
}

CallExpr <- exp:Expr '(' args:CallArgumentList? ')' {
  call := CallExpr{
    Expr: exp.(Expr),
  }

  if args != nil {
    call.Args = args.([]Expr)
  }

  return call, nil
}

CallArgumentList <- _ exp:Expr _ rest:CallArgumentListComma? {
  if rest != nil {
    return append([]Expr{exp.(Expr)}, rest.([]Expr)...), nil
  }

  return []Expr{exp.(Expr)}, nil
}

CallArgumentListComma <- ',' rest:CallArgumentList {
  return rest, nil
}

DotExpr <- exp:Expr '.' ident:Identifier {
  return DotExpr{
    Expr:exp.(Expr),
    Key:ident.(Identifier),
  }, nil
}

BinaryExpr <- left:Expr _ op:("**") _ right:Expr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),
  }, nil
} / left:Expr _ op:("*" / "/" / "%" / "<<" / ">>" / "&") _ right:Expr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),
  }, nil
} / left:Expr _ op:("+" / "-" / "|" / "^") _ right:Expr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),
  }, nil
} / left:Expr _ op:("==" / "!=" / "<" / ">" / ">=" / "<=") _ right:Expr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),
  }, nil
} / left:Expr _ op:("&&") _ right:Expr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),
  }, nil
} / left:Expr _ op:("||") _ right:Expr {
  return BinaryExpr{
    Left: left.(Expr),
    Operator: Operator(op.([]byte)),
    Right: right.(Expr),
  }, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

_ "whitespace" <- [ \n\t\r]*

EOF <- !.
