
; Utilities
;

function @aeon_fatal()
	var $x = "hello"
	$x = $x:number

function @debug($s:text)
	{{if .Debug}}print("debug: " & $s){{end}}

function @__builtin_panic($s:text)
	var $msg = "panic: " & $s
	@debug($msg)
	print($msg)
	@aeon_fatal()

function @__builtin_assert($cond:number, $msg:text)
	if !($cond)
		print(text("assertion failed: {}", $msg))
		@aeon_fatal()

function @aeon_trunc($a:number):number
	return $a - ($a %1)

function @__builtin_sin($n:number):number
	return sin($n)

function @__builtin_cos($n:number):number
	return cos($n)

; Memory Layout

{{$PageSize := .PageSize}}
const $PAGE_SIZE = {{$PageSize}}

{{range $page := loop 0 .NumCodePages -}}
array $aeon_code_page_{{$page}}:number
{{end}}
{{range $page := loop 0 .NumMemPages -}}
array $aeon_mem_page_{{$page}}:number
{{end}}
{{range $page := loop 0 .NumStrPages -}}
array $aeon_str_page_{{$page}}:text
{{end}}
var $aeon_str_index = 0
array $aeon_reg:number

function @aeon_code_init()
	{{range $page := loop 0 .NumCodePages}}$aeon_code_page_{{$page}}.fill($PAGE_SIZE, 0){{"\n\t"}}{{end}}
	{{range $addr, $bc := .Code}}$aeon_code_page_{{$addr.Page}}.{{$addr.Addr}} = {{$bc}}{{"\n\t"}}{{end}}

function @aeon_code($addr:number):number
	if ($addr < {{$PageSize}})
		return $aeon_code_page_0.$addr

	var $pageAddr = $addr % $PAGE_SIZE

	{{range $page := loop 1 .NumCodePages}}
	if ($addr < {{mul (add $page 1) $PageSize}})
		return $aeon_code_page_{{$page}}.$pageAddr
	{{ end }}

function @aeon_reg_init()
	$aeon_reg.fill({{.NumRegisters}}, 0)

function @aeon_mem_load($addr:number):number
	if $addr < {{$PageSize}}
		return $aeon_mem_page_0.$addr

	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 1 .NumMemPages}}
	if ($addr < {{mul (add $page 1) $PageSize}})
		return $aeon_mem_page_{{$page}}.$pageAddr
	{{end}}

function @aeon_mem_store($addr:number, $v:number):text
	if $addr < {{$PageSize}}
		$aeon_mem_page_0.$addr = $v

	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 1 .NumMemPages}}
	if ($addr < {{mul (add $page 1) $PageSize}})
		$aeon_mem_page_{{$page}}.$pageAddr = $v
	{{end}}

function @aeon_mem_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_mem_page_{{$page}}.fill($PAGE_SIZE, 0){{"\n\t"}}{{end}}

array $aeon_memmove_tmp:number
function @aeon_memmove($dst:number, $src:number, $size:number)
	$aeon_memmove_tmp.fill($size, 0)
	repeat $size ($i)
		$aeon_memmove_tmp.$i = @aeon_mem_load($src+$i)
	repeat $size ($i)
		@aeon_mem_store($dst+$i, $aeon_memmove_tmp.$i)

function @aeon_str_load($addr:number):text
	if $addr < {{$PageSize}}
		return $aeon_str_page_0.$addr

	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 1 .NumStrPages}}
	if ($addr < {{mul (add $page 1) $PageSize}})
		return $aeon_str_page_{{$page}}.$pageAddr
	{{end}}

function @aeon_str_store($addr:number, $v:text):text
	if $addr < {{$PageSize}}
		$aeon_str_page_0.$addr = $v

	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 1 .NumStrPages}}
	if ($addr < {{mul (add $page 1) $PageSize}})
		$aeon_str_page_{{$page}}.$pageAddr = $v
	{{end}}

function @aeon_str_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_str_page_{{$page}}.fill($PAGE_SIZE, ""){{"\n\t"}}{{end}}
	{{range $i, $str := .Strings }}@aeon_str_store({{$i}}, "{{$str}}"){{"\n\t"}}{{end}}
	$aeon_str_index = {{len .Strings}}

function @aeon_str_alloc($v:text):number
	$aeon_str_index++
	@aeon_str_store($aeon_str_index, $v)
	return $aeon_str_index

function @aeon_vtable($type:number, $name:text):number
	{{range $type, $typeTable := .VTable}}if ($type == {{$type}}){{"\n\t\t"}}{{range $name, $addr := $typeTable}}if ($name == "{{$name}}"){{"\n\t\t\t"}}return {{$addr}}{{"\n\t\t"}}{{end}}{{"\n\t"}}{{end}}

; Heap
var $aeon_heap_start:number
var $aeon_heap_index:number

function @aeon_heap_init()
	$aeon_heap_start = {{div (mul .NumMemPages $PageSize) 2}}
	$aeon_heap_index = $aeon_heap_start

function @aeon_heap_alloc($size:number):number
	var $addr = $aeon_heap_index
	$aeon_heap_index += $size

	{{if .Debug}}@debug(text("heap alloc {} -> {}", $size, $addr)){{end}}

	; TODO: bounds checking
	return $addr

; Operand Evaluation
array $aeon_ops:text
var $aeon_op = ""
array $aeon_op_uops:text
array $aeon_op_arg_stack:number

var $aeon_numbers = "0123456789"

function @aeon_load($addr:number, $length:number):number
	var $arg1 = 0
	var $arg2 = 0

	var $limit = $addr+$length

	while ($addr < $limit)
		var $uop = @aeon_code($addr)
		$addr++
		if ($uop == 0) ; immediate
			var $imm = @aeon_code($addr)
			$addr++
			$aeon_op_arg_stack.append($imm)
		elseif ($uop == 1) ; register
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($aeon_reg.$arg1)
		elseif ($uop == 2) ; memory
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(@aeon_mem_load($arg1))
		elseif ($uop == 3) ; vtable
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(@aeon_vtable($arg1, @aeon_str_load($arg2)))
		elseif ($uop == 4) ; +
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 + $arg2)
		elseif ($uop == 5) ; -
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 - $arg2)
		elseif ($uop == 6) ; *
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 * $arg2)
		elseif ($uop == 11) ; =
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 == $arg2)
		elseif ($uop == 12) ; !=
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 != $arg2)
		elseif ($uop == 13) ; !
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(!$arg1)
		elseif ($uop == 14) ; -
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(-$arg1)
		elseif ($uop == 15)
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			if ($arg1 >= $arg2)
				print(text("index out of bounds: {} {}", $arg1, $arg2))
				@aeon_fatal()
		elseif ($uop == 16) ; >
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 > $arg2)
		elseif ($uop == 17) ; >=
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 >= $arg2)
		elseif ($uop == 18) ; <
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 < $arg2)
		elseif ($uop == 19) ; <=
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 <= $arg2)
		else
			print(text("bad uop in load {} at addr {}", $uop, $addr-1))
			$aeon_op_arg_stack.append($arg1)
			@aeon_fatal()

	var $ret = $aeon_op_arg_stack.0
	$aeon_op_arg_stack.clear()
	return $ret

function @aeon_load_addr($op:number):number
	var $length = @aeon_code($op)

	var $last = @aeon_code($op+$length)

	if ($last == 2) ; mem
		return @aeon_load($op+1, $length-1)
	else
		@__builtin_panic(text("bad operand for load addr {}", $last))

function @aeon_load_addr_internal($op:number, $length:number):number
	var $last = @aeon_code($op+$length-1)

	if ($last == 2) ; mem
		return @aeon_load($op, $length-1)
	else
		@__builtin_panic(text("bad operand for load addr {}", $last))

function @aeon_store($op:number, $v:number)
	var $length = @aeon_code($op)

	var $last = @aeon_code($op+$length)

	if $last == 1 ; reg
		var $reg = @aeon_load($op+1, $length-1)
		$aeon_reg.$reg = $v
	elseif $last == 2 ; mem
		var $addr = @aeon_load($op+1, $length-1)
		@aeon_mem_store($addr, $v)
	else
		@__builtin_panic(text("bad operand for store {} on {}", $op, $aeon_reg.0))

function @aeon_store_internal($op:number, $length:number, $v:number)
	var $last = @aeon_code($op+$length-1)

	if $last == 1 ; reg
		var $reg = @aeon_load($op, $length-1)
		$aeon_reg.$reg = $v
	elseif $last == 2 ; mem
		var $addr = @aeon_load($op, $length-1)
		@aeon_mem_store($addr, $v)
	else
		@__builtin_panic(text("bad operand for store {} on {}", $op, $aeon_reg.0))

function @aeon_add_string($a:number, $b:number):number
	return @aeon_str_alloc(@aeon_str_load($a) & @aeon_str_load($b))

function @aeon_eq_string($a:number, $b:number):number
	return $a==$b || (@aeon_str_load($a) == @aeon_str_load($b))

function @aeon_ne_string($a:number, $b:number):number
	return $a!=$b && (@aeon_str_load($a) != @aeon_str_load($b))

function @itoa($n:number):number
	return @aeon_str_alloc($n:text)

; Advanced Builtins

function @aeon_append($data:number, $len:number, $cap:number, $elem:number, $size:number, $ret:number)
	@__builtin_assert($cap >= $len, "append: cap < len")
	if ($len == $cap)
		if $cap == 0
			$cap = 64 ; TODO: tune this?
		else
			$cap *= 2

		var $newData = @aeon_heap_alloc($cap * $size)
		var $totalSize = $len * $size
		repeat $totalSize ($i)
			@aeon_mem_store($newData + $i, @aeon_mem_load($data + $i))

		$data = $newData

	if $size == 1
		@aeon_mem_store($data + ($len * $size), $elem)
	else
		repeat $size ($i)
			@aeon_mem_store($data + ($len * $size) + $i, @aeon_mem_load($elem + $i))
	@aeon_mem_store($ret, $data)
	@aeon_mem_store($ret + 1, $len + 1)
	@aeon_mem_store($ret + 2, $cap)
	return

function @aeon_to_string($type:number, $value:number):text
	var $kind = @aeon_vtable($type, "#kind")
	if $kind == {{.KindNil}}
		return "<nil>"
	elseif $kind == {{.KindInt}}
		return $value:text
	elseif $kind == {{.KindFloat}}
		return $value:text
	elseif $kind == {{.KindString}}
		return @aeon_str_load($value)
	elseif $kind == {{.KindBool}}
		if $value
			return "true"
		else
			return "false"
	elseif $kind == {{.KindPointer}}
		return $value:text
	else
		var $name = @aeon_vtable($type, "#name")
		return text("<unhandled type: {}>", $name)

function @aeon_type_kind($type:number):number
	return @aeon_vtable($type, "#kind")

function @aeon_kind_is_numeric($kind:number):number
	return $kind == {{.KindInt}} || $kind == {{.KindFloat}}

function @aeon_fmt_string_spec($lead:number, $trail:number, $signSpace:number):text
	var $str = "{"
	if $lead > 0 && $trail > 0
		$lead -= $trail+1

	if $lead > 0
		repeat $lead ($_)
			$str &= "0"

	if $trail > 0
		if $lead == 0
			$str &= "0"
		$str &= "."
		repeat $trail ($_)
			$str &= "0"

	$str &= "}"
	return $str

function @printf($fmt:text, $data:number, $len:number, $cap:number)
	var $size = 2

	var $str = ""
	var $index = 0
	var $mode = 0
	var $lead = 0
	var $trail = 0
	var $argIndex = 0
	var $signSpace = 0
	var $type = 0
	var $value = 0
	while ($index < size($fmt))
		var $c = $fmt.$index
		$index++
		if $mode == 0
			$trail = 0
			$lead = 0
			$signSpace = 0
			if $c == "%"
				$mode = 1
			else
				$str &= $c
		elseif $mode == 1
			if $c == "%"
				$str &= "%"
				$mode = 0
			elseif $c == "0"
				$mode = 2
			elseif $c == "."
				$mode = 3
			elseif $c == " " && !$signSpace
				$signSpace = 1
			else
				$type = @aeon_mem_load($data + ($size * $argIndex))
				$value = @aeon_mem_load($data + ($size * $argIndex) + 1)
				$str &= @aeon_to_string($type, $value)
				$argIndex++
				$mode = 0
		elseif $mode == 2
			if find($aeon_numbers, $c) != -1
				$lead = $lead * 10 + $c:number
			elseif $c == "."
				$mode = 3
			elseif $c == "f" || $c == "d"
				$type = @aeon_mem_load($data + ($size * $argIndex))
				if !@aeon_kind_is_numeric(@aeon_type_kind($type))
					@__builtin_panic(text("invalid type for numeric format: {}", $type))
				$value = @aeon_mem_load($data + ($size * $argIndex) + 1)
				if $signSpace
					if $value >= 0
						$str &= " "
					else
						$str &= "-"
				$str &= text(@aeon_fmt_string_spec($lead-$signSpace, $trail), abs($value))
				$argIndex++
				$mode = 0
			else
				@__builtin_panic(text("invalid format string: {}", $fmt))
		elseif $mode == 3
			if find($aeon_numbers, $c) != -1
				$trail = $trail * 10 + $c:number
			elseif $c == "f"
				$type = @aeon_mem_load($data + ($size * $argIndex))
				if !@aeon_kind_is_numeric(@aeon_type_kind($type))
					@__builtin_panic(text("invalid type for numeric format: {}", $type))
				$value = @aeon_mem_load($data + ($size * $argIndex) + 1)
				if $signSpace
					if $value >= 0
						$str &= " "
					else
						$str &= "-"
				$str &= text(@aeon_fmt_string_spec($lead-$signSpace, $trail), abs($value))
				$argIndex++
				$mode = 0
			else
				@__builtin_panic(text("invalid format string: {}", $fmt))

	print($str)

function @print($data:number, $len:number, $cap:number)
	var $size = 2

	var $str = ""

	repeat $len ($i)
		var $type = @aeon_mem_load($data + ($size * $i))
		var $value = @aeon_mem_load($data + ($size * $i) + 1)

		$str &= @aeon_to_string($type, $value)
		if $i < $len - 1
			$str &= " "

	print($str)
	

; Extern Calls
function @aeon_call_size($fname:text):number
	var $sp = $aeon_reg.1
	{{ range $entry := .ExternFuncs }}
	if ($fname == "{{$entry.Name}}")
		return {{$entry.Size}}
	{{ end }}

	print(text("invalid extern func {}", $fname))
	@aeon_fatal()


function @aeon_call_extern($fname:text, $size:number)
	var $sp = $aeon_reg.1
	{{ range $entry := .ExternFuncs }}
	if ($fname == "{{$entry.Name}}")
		{{if $entry.HasReturn}}@aeon_mem_store($aeon_reg.1 - $size, {{end}}@{{$entry.Name}}({{range $i, $t := $entry.ArgTypes}}{{if $i }},{{end}}{{$t.Prefix}}@aeon_mem_load($sp-{{len $entry.ArgTypes}}+{{$i}}){{$t.Suffix}}{{end}}){{if $entry.HasReturn}}){{end}}
	{{ end }}

; Main Loop

function @aeon_run($funcInfo:number):number
	@aeon_reg_init()

	var $line = 0
	var $sizeLen = 0
	var $size = 0
	var $kind = 0
	var $op = 0

	var $targetLen = 0
	var $target = 0
	var $condLen = 0
	var $cond = 0
	var $srcLen = 0
	var $src = 0
	var $dstLen = 0
	var $dst = 0
	var $leftLen = 0
	var $left = 0
	var $rightLen = 0
	var $right = 0
	var $elemLen = 0
	var $elem = 0
	var $funcLen = 0
	var $func = 0

	$aeon_reg.0 = @aeon_mem_load($funcInfo+3)
	$aeon_reg.1 = {{.GlobalSize}}

	repeat {{.NumRegisters}} ($reg)
		@aeon_mem_store($aeon_reg.1, 0)
		$aeon_reg.1 += 1

	$aeon_reg.2 = $aeon_reg.1 - 1

	var $i = 0

	while ($i < 1000000)
		$i++

		var $code = @aeon_code($aeon_reg.0)
		if ($code == 0); nop
			$aeon_reg.0+=1
		elseif ($code == 1); mov <#size> <dst> <src>
			$size = @aeon_code($aeon_reg.0+1)
			$dstLen = @aeon_code($aeon_reg.0+2)
			$srcLen = @aeon_code($aeon_reg.0+3+$dstLen)

			if $size == 1
				@aeon_store_internal($aeon_reg.0+3, $dstLen, @aeon_load($aeon_reg.0+4+$dstLen, $srcLen))
			else
				$dst = @aeon_load_addr_internal($aeon_reg.0+3, $dstLen)
				$src = @aeon_load_addr_internal($aeon_reg.0+4+$dstLen, $srcLen)
				@aeon_memmove($dst, $src, $size)
			$aeon_reg.0 += 4 + $srcLen + $dstLen
		elseif $code == 2; jmp <target> <cond>
			$targetLen = @aeon_code($aeon_reg.0+1)
			$target = @aeon_load($aeon_reg.0+2, $targetLen)
			$condLen = @aeon_code($aeon_reg.0+2+$targetLen)
			$cond = @aeon_load($aeon_reg.0+3+$targetLen, $condLen)

			if $cond
				$aeon_reg.0 = $target
			else
				$aeon_reg.0 += 3 + $targetLen + $condLen
		elseif $code == 3; bop <dst> <#kind> <#op> <left> <right>
			$dstLen = @aeon_code($aeon_reg.0+1)

			$kind = @aeon_code($aeon_reg.0+2+$dstLen)
			$op = @aeon_code($aeon_reg.0+3+$dstLen)

			$leftLen = @aeon_code($aeon_reg.0+4+$dstLen)
			$left = @aeon_load($aeon_reg.0+5+$dstLen, $leftLen)
			$rightLen = @aeon_code($aeon_reg.0+5+$dstLen+$leftLen)
			$right = @aeon_load($aeon_reg.0+6+$dstLen+$leftLen, $rightLen)

			if $op == 4; +
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left + $right)
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left + $right)
				elseif $kind == {{.KindString}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, @aeon_add_string($left, $right))
				else
					@__builtin_panic("bad + operand")
			elseif $op == 5; -
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left - $right)
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left - $right)
				else
					@__builtin_panic("bad - operand")
			elseif $op == 6; *
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left * $right)
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left * $right)
				else
					@__builtin_panic(text("bad * operand: {}", $kind))
			elseif $op == 7; /
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, @aeon_trunc($left / $right))
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left / $right)
				else
					@__builtin_panic(text("bad / operand: {}", $kind))
			elseif $op == 8; %
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left % $right)
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left % $right)
				else
					@__builtin_panic(text("bad % operand: {}", $kind))
			elseif $op == 9; &&
				if $kind == {{.KindBool}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left && $right)
				else
					@__builtin_panic("bad && operand")
			elseif $op == 10; ||
				if $kind == {{.KindBool}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left || $right)
				else
					@__builtin_panic("bad || operand")
			elseif $op == 11; ==
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left == $right)
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left == $right)
				elseif $kind == {{.KindBool}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left == $right)
				elseif $kind == {{.KindPointer}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left == $right)
				elseif $kind == {{.KindType}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left == $right)
				elseif $kind == {{.KindString}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, @aeon_eq_string($left, $right))
				else
					@__builtin_panic("bad == operand")
			elseif $op == 12; !=
				if $kind == {{.KindInt}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left != $right)
				elseif $kind == {{.KindFloat}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left != $right)
				elseif $kind == {{.KindBool}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left != $right)
				elseif $kind == {{.KindPointer}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left != $right)
				elseif $kind == {{.KindType}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, $left != $right)
				elseif $kind == {{.KindString}}
					@aeon_store_internal($aeon_reg.0+2, $dstLen, @aeon_ne_string($left, $right))
				else
					@__builtin_panic("bad + operand")
			else
				@__builtin_panic(text("bad bop {}", $op))

			$aeon_reg.0 += 6 + $dstLen + $leftLen + $rightLen
		elseif $code == 4; unop <dst> <#kind> <#op> <src>
			$dstLen = @aeon_code($aeon_reg.0+1)
			$kind = @aeon_code($aeon_reg.0+2+$dstLen)
			$op = @aeon_code($aeon_reg.0+3+$dstLen)
			$srcLen = @aeon_code($aeon_reg.0+4+$dstLen)
			$src = @aeon_load($aeon_reg.0+5+$dstLen, $srcLen)

			if $op == 13; !
				if $kind == {{.KindBool}}
					@aeon_store($aeon_reg.0+1, !$src)
				else
					@__builtin_panic("bad ! operand")
			elseif $op == 14; -
				if $kind == {{.KindInt}}
					@aeon_store($aeon_reg.0+1, -$src)
				elseif $kind == {{.KindFloat}}
					@aeon_store($aeon_reg.0+1, -$src)
				else
					@__builtin_panic("bad - operand")
			else
				@__builtin_panic(text("bad unop {}", $op))

			$aeon_reg.0 += 5 + $dstLen + $srcLen
		elseif $code == 5; call <#line> <func>
			$line = @aeon_code($aeon_reg.0+1)
			$funcLen = @aeon_code($aeon_reg.0+2)
			$func = @aeon_load($aeon_reg.0+3, $funcLen)

			var $ftype = @aeon_mem_load($func)
			var $fname = @aeon_str_load(@aeon_mem_load($func+1))

			if $ftype == 0
				@__builtin_panic(text("invalid function call: {}", $fname))
			elseif $ftype == 1
				var $externName = @aeon_str_load(@aeon_mem_load($func+3))

				$size = @aeon_call_size($externName)
				@aeon_call_extern($externName, $size)
				$aeon_reg.1 -= $size
				$aeon_reg.0 += 3 + $funcLen
			elseif $ftype == 2
				var $faddr = @aeon_mem_load($func+3)

				$aeon_reg.0 += 3 + $funcLen

				repeat {{.NumRegisters}} ($reg)
					@aeon_mem_store($aeon_reg.1 - $reg + {{.NumRegisters}} - 1, $aeon_reg.$reg)

				$aeon_reg.1 += {{.NumRegisters}}
				$aeon_reg.2 = $aeon_reg.1 - 1
				$aeon_reg.0 = $faddr
			else
				@__builtin_panic(text("invalid function type: {}", $ftype))
		elseif $code == 6; ret <#size>
			$size = @aeon_code($aeon_reg.0+1)
			var $fp = $aeon_reg.2
			repeat {{.NumRegisters}} ($reg)
				$aeon_reg.$reg = @aeon_mem_load($fp - $reg)

			$aeon_reg.1 -= $size

			; TODO: stack tracing
			;
			if $aeon_reg.2 == 0
				return
		elseif $code == 7; alc <dst> <size>
			$dstLen = @aeon_code($aeon_reg.0+1)

			$sizeLen = @aeon_code($aeon_reg.0+2+$dstLen)
			$size = @aeon_load($aeon_reg.0+3+$dstLen, $sizeLen)

			@aeon_store($aeon_reg.0+1, @aeon_heap_alloc($size))

			$aeon_reg.0 += 3 + $dstLen + $sizeLen
		elseif $code == 8; app <dst> <src> <elem> <#size>
			$dstLen = @aeon_code($aeon_reg.0+1)
			$dst = @aeon_load_addr_internal($aeon_reg.0+2, $dstLen)
			$srcLen = @aeon_code($aeon_reg.0+2+$dstLen)
			$src = @aeon_load_addr_internal($aeon_reg.0+3+$dstLen, $srcLen)
			$elemLen = @aeon_code($aeon_reg.0+3+$dstLen+$srcLen)
			$size = @aeon_code($aeon_reg.0+4+$dstLen+$srcLen+$elemLen)

			var $sliceData = @aeon_mem_load($src)
			var $sliceLen = @aeon_mem_load($src+1)
			var $sliceCap = @aeon_mem_load($src+2)

			if $sliceCap < $sliceLen
				@__builtin_panic("slice cap < len")

			if $sliceLen == $sliceCap
				if $sliceCap == 0
					$sliceCap = 1
				else
					$sliceCap *= 2
				var $newSliceData = @aeon_heap_alloc($sliceCap * $size)

				; TODO: memcpy
				@aeon_memmove($newSliceData, $sliceData, $sliceLen * $size)

				$sliceData = $newSliceData

			if $size == 1
				$elem = @aeon_load($aeon_reg.0+4+$dstLen+$srcLen, $elemLen)
				@aeon_mem_store($sliceData + ($sliceLen * $size), $elem)
			else
				; TODO: memcpy
				$elem = @aeon_load_addr_internal($aeon_reg.0+4+$dstLen+$srcLen, $elemLen)
				@aeon_memmove($sliceData + ($sliceLen * $size), $elem, $size)

			@aeon_mem_store($dst, $sliceData)
			@aeon_mem_store($dst+1, $sliceLen+1)
			@aeon_mem_store($dst+2, $sliceCap)

			$aeon_reg.0 += 5 + $dstLen + $srcLen + $elemLen
		else
			@__builtin_panic(text("bad opcode {}", $code))

init
	@aeon_reg_init()
	@aeon_code_init()
	@aeon_mem_init()
	@aeon_str_init()
	@aeon_heap_init()
{{range $addr := .VarInitFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}
{{range $addr := .InitFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}

tick
{{range $addr := .UpdateFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}
