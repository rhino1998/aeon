
; Utilities
;

function @aeon_fatal()
	var $x = "hello"
	$x = $x:number

function @debug($s:text)
	{{if .Debug}}print("debug: " & $s){{end}}

function @__builtin_panic($s:text)
	var $msg = "panic: " & $s
	@debug($msg)
	print($msg)
	@aeon_fatal()

function @__builtin_assert($cond:number, $msg:text)
	if !($cond)
		print(text("assertion failed: {}", $msg))
		@aeon_fatal()

function @aeon_trunc($a:number):number
	return $a - ($a %1)

function @__builtin_sin($n:number):number
	return sin($n)

function @__builtin_cos($n:number):number
	return cos($n)

; Memory Layout
const $PAGE_SIZE = {{.PageSize}}

{{range $page := loop 0 .NumCodePages -}}
array $aeon_code_page_{{$page}}:text
{{end}}
{{range $page := loop 0 .NumMemPages -}}
array $aeon_mem_page_{{$page}}:number
{{end}}
{{range $page := loop 0 .NumStrPages -}}
array $aeon_str_page_{{$page}}:text
{{end}}
var $aeon_str_index = 0
array $aeon_reg:number

function @aeon_code_init()
	{{range $page := loop 0 .NumCodePages}}$aeon_code_page_{{$page}}.fill($PAGE_SIZE, ""){{"\n\t"}}{{end}}
	{{range $addr, $bc := .Code}}$aeon_code_page_{{$addr.Page}}.{{$addr.Addr}} = "{{$bc}}"{{"\n\t"}}{{end}}

function @aeon_code($addr:number):text
	var $page = @aeon_trunc($addr / $PAGE_SIZE)
	var $pageAddr = @aeon_trunc($addr % $PAGE_SIZE)
	{{range $page := loop 0 .NumCodePages}}
	if ($page == {{$page}})
		return $aeon_code_page_{{$page}}.$pageAddr
	{{ end }}

function @aeon_reg_load($reg:number):number
	return $aeon_reg.$reg

function @aeon_reg_store($reg:number, $v:number)
	$aeon_reg.$reg = $v

function @aeon_reg_init()
	$aeon_reg.fill({{.NumRegisters}}, 0)

function @aeon_mem_load($addr:number):number
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 0 .NumMemPages}}
	if ($page == {{$page}})
		return $aeon_mem_page_{{$page}}.$pageAddr
	{{end}}

function @aeon_mem_store($addr:number, $v:number):text
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE

	{{range $page := loop 0 .NumMemPages}}
	if ($page == {{$page}})
		$aeon_mem_page_{{$page}}.$pageAddr = $v
	{{end}}

function @aeon_mem_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_mem_page_{{$page}}.fill($PAGE_SIZE, 0){{"\n\t"}}{{end}}

function @aeon_str_load($addr:number):text
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 0 .NumStrPages}}
	if ($page == {{$page}})
		return $aeon_str_page_{{$page}}.$pageAddr
	{{end}}

function @aeon_str_store($addr:number, $v:text):text
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE

	{{range $page := loop 0 .NumStrPages}}
	if ($page == {{$page}})
		$aeon_str_page_{{$page}}.$pageAddr = $v
	{{end}}

function @aeon_str_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_str_page_{{$page}}.fill($PAGE_SIZE, ""){{"\n\t"}}{{end}}
	{{range $i, $str := .Strings }}@aeon_str_store({{$i}}, "{{$str}}"){{"\n\t"}}{{end}}
	$aeon_str_index = {{len .Strings}}

function @aeon_str_alloc($v:text):number
	$aeon_str_index++
	@aeon_str_store($aeon_str_index, $v)
	return $aeon_str_index

function @aeon_vtable($type:number, $name:text):number
	{{range $type, $typeTable := .VTable}}if ($type == {{$type}}){{"\n\t\t"}}{{range $name, $addr := $typeTable}}if ($name == "{{$name}}"){{"\n\t\t\t"}}return {{$addr}}{{"\n\t\t"}}{{end}}{{"\n\t"}}{{end}}

; Heap
var $aeon_heap_start:number
var $aeon_heap_index:number

function @aeon_heap_init()
	$aeon_heap_start = @aeon_trunc({{.NumMemPages}} * {{.PageSize}} / 2)
	$aeon_heap_index = $aeon_heap_start

function @aeon_heap_alloc($size:number):number
	var $addr = $aeon_heap_index
	$aeon_heap_index += $size

	{{if .Debug}}@debug(text("heap alloc {} -> {}", $size, $addr)){{end}}

	; TODO: bounds checking
	return $addr

; Operand Evaluation
array $aeon_ops:text
var $aeon_op = ""
array $aeon_op_uops:text
array $aeon_op_arg_stack:number

var $aeon_numbers = "0123456789"

function @aeon_load_internal($op:text):number
	var $index = 0
	var $mode = 0
	var $arg1 = 0
	var $arg2 = 0
	var $sign = 1
	while ($index < size($op))
		var $k = $op.$index
		$index++
		if ($mode == 0)
			if ($k == "I")
				$mode = 1
				$aeon_op_arg_stack.append(0)
			elseif ($k == "R")
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append(@aeon_reg_load($arg1))
			elseif ($k == "@")
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append(@aeon_mem_load($arg1))
			elseif ($k == "+")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 + $arg2)
			elseif ($k == "*")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 * $arg2)
			elseif ($k == "=")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 == $arg2)
			elseif ($k == "≠")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 != $arg2)
			elseif ($k == "󰥽")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 <= $arg2)
			elseif ($k == "<")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 < $arg2)
			elseif ($k == "-")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1 - $arg2)
			elseif ($k == "!")
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append(!$arg1)
			elseif ($k == "V")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append(@aeon_vtable($arg1, @aeon_str_load($arg2)))
			elseif ($k == "#")
				$arg2 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				if ($arg1 >= $arg2)
					print(text("index out of bounds: {} {}", $arg1, $arg2))
					@aeon_fatal()
			else
				print(text("bad uop in load {} at index {} in {}", $k, $index-1, $op))
				$aeon_op_arg_stack.append($arg1)
				@aeon_fatal()
		elseif ($mode == 1)
			if (find($aeon_numbers, $k) != -1)
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append((($arg1 * 10) + ($k:number)))
			elseif ($k == "-")
				$sign = -1
			else
				$arg1 = $aeon_op_arg_stack.last
				$aeon_op_arg_stack.pop()
				$aeon_op_arg_stack.append($arg1*$sign)
				$mode = 0
				$index--

	var $ret = $aeon_op_arg_stack.0
	$aeon_op_arg_stack.clear()
	return $ret

function @aeon_load($op:text):number
	var $ret = @aeon_load_internal($op)
	{{if .Debug}}@debug(text("load {} -> {}", $op, $ret)){{end}}
	return $ret

function @aeon_load_addr($op:text):number
	if (last($op) == "@")
		return @aeon_load_internal(substring($op, 0, size($op)-1))
	else
		@__builtin_panic(text("bad operand for load addr {}", $op))

function @aeon_mov_size($dst:text, $src:text, $size:number)
	var $dstAddr = @aeon_load_addr($dst)
	var $srcAddr = @aeon_load_addr($src)

	repeat $size ($offset)
		@aeon_mem_store($dstAddr+$offset, @aeon_mem_load($srcAddr+$offset))

function @aeon_mov_init($dst:text, $src:text, $size:number)
	var $dstAddr = @aeon_load_addr($dst)
	var $srcVal = @aeon_load($src)

	repeat $size ($offset)
		@aeon_mem_store($dstAddr+$offset, $srcVal)


function @aeon_load_field($op:text, $offset:number):number
	return @aeon_mem_load(@aeon_load($op) + $offset)

function @aeon_store($op:text, $v:number)
	if (last($op) == "R")
		var $reg = @aeon_load_internal(substring($op, 0, size($op)-1))
		{{if .Debug}}@debug(text("store {} -> R{} = {}", $op, $reg, $v)){{end}}
		@aeon_reg_store($reg, $v)
	elseif (last($op) == "@")
		var $addr = @aeon_load_internal(substring($op, 0, size($op)-1))
		{{if .Debug}}@debug(text("store {} -> @{} = {}", $op, $addr, $v)){{end}}
		@aeon_mem_store($addr, $v)
	else
		print(text("bad operand for store {}", $op))
		@aeon_fatal()

function @aeon_add_string($a:number, $b:number):number
	return @aeon_str_alloc(@aeon_str_load($a) & @aeon_str_load($b))

function @aeon_eq_string($a:number, $b:number):number
	return $a==$b || (@aeon_str_load($a) == @aeon_str_load($b))

function @aeon_ne_string($a:number, $b:number):number
	return $a!=$b && (@aeon_str_load($a) != @aeon_str_load($b))

function @itoa($n:number):number
	return @aeon_str_alloc($n:text)

function @aeon_bop($kind:number, $op:text, $a:text, $b:text):number
	var $av = @aeon_load($a)
	var $bv = @aeon_load($b)


	if ($op == "==")
		if ($kind == {{.KindString}})
			return @aeon_eq_string($av, $bv)
		else
			return $av == $bv

	if ($op == "!=")
		if ($kind == {{.KindString}})
			return @aeon_ne_string($av, $bv)
		else
			return $av != $bv

	if ($op == "+")
		if ($kind == {{.KindInt}})
			return $av + $bv
		elseif ($kind == {{.KindFloat}})
			return $av + $bv
		elseif ($kind == {{.KindString}})
			return @aeon_add_string($av, $bv)
		@__builtin_panic("bad + operand")

	if ($op == "-")
		if ($kind == {{.KindInt}})
			return $av - $bv
		elseif ($kind == {{.KindFloat}})
			return $av - $bv
		@__builtin_panic("bad - operand")

	if ($op == "*")
		if ($kind == {{.KindInt}})
			return $av * $bv
		elseif ($kind == {{.KindFloat}})
			return $av * $bv
		@__builtin_panic("bad * operand")

	if ($op == "/")
		if ($kind == {{.KindInt}})
			return @aeon_trunc($av / $bv)
		elseif ($kind == {{.KindFloat}})
			return $av / $bv
		@__builtin_panic("bad / operand")

	if ($op == "%")
		if ($kind == {{.KindInt}})
			return $av % $bv
		elseif ($kind == {{.KindFloat}})
			return $av % $bv
		@__builtin_panic("bad % operand")

	if ($op == "**")
		if ($kind == {{.KindInt}})
			return $av ^ $bv
		elseif ($kind == {{.KindFloat}})
			return $av ^ $bv
		@__builtin_panic("bad ** operand")

	if ($op == "<")
		if ($kind == {{.KindInt}})
			return $av < $bv
		elseif ($kind == {{.KindFloat}})
			return $av < $bv
		@__builtin_panic("bad < operand")

	if ($op == ">")
		if ($kind == {{.KindInt}})
			return $av > $bv
		elseif ($kind == {{.KindFloat}})
			return $av > $bv
		@__builtin_panic("bad > operand")

	if ($op == ">=")
		if ($kind == {{.KindInt}})
			return $av >= $bv
		elseif ($kind == {{.KindFloat}})
			return $av >= $bv
		@__builtin_panic("bad >= operand")

	if ($op == "<=")
		if ($kind == {{.KindInt}})
			return $av <= $bv
		elseif ($kind == {{.KindFloat}})
			return $av <= $bv
		@__builtin_panic("bad <= operand")


function @aeon_uop($op:text, $a:text):number
	var $av = @aeon_load($a)

	if ($op == "-I")
		return -$av
	elseif ($op == "-F")
		return -$av
	elseif ($op == "+I")
		return +$av
	elseif ($op == "+F")
		return +$av
	else
		print(text("bad unary operand {} {} {}", $op, $a))
		@aeon_fatal()

; Advanced Builtins

function @aeon_append($data:number, $len:number, $cap:number, $elem:number, $size:number, $ret:number)
	@__builtin_assert($cap >= $len, "append: cap < len")
	if ($len == $cap)
		if $cap == 0
			$cap = 64 ; TODO: tune this?
		else
			$cap *= 2

		var $newData = @aeon_heap_alloc($cap * $size)
		var $totalSize = $len * $size
		repeat $totalSize ($i)
			@aeon_mem_store($newData + $i, @aeon_mem_load($data + $i))

		$data = $newData

	if $size == 1
		@aeon_mem_store($data + ($len * $size), $elem)
	else
		repeat $size ($i)
			@aeon_mem_store($data + ($len * $size) + $i, @aeon_mem_load($elem + $i))
	@aeon_mem_store($ret, $data)
	@aeon_mem_store($ret + 1, $len + 1)
	@aeon_mem_store($ret + 2, $cap)
	return

function @print($type:number, $value:number)
	var $kind = @aeon_vtable($type, "#kind")
	if $kind == {{.KindNil}}
		print("<nil>")
	elseif $kind == {{.KindInt}}
		print($value)
	elseif $kind == {{.KindFloat}}
		print($value)
	elseif $kind == {{.KindString}}
		print(@aeon_str_load($value))
	elseif $kind == {{.KindBool}}
		if $value
			print("true")
		else
			print("false")
	else
		print(text("unknown kind: {}", $kind))

; Extern Calls
function @aeon_call_size($fname:text):number
	var $sp = $aeon_reg.1
	{{ range $entry := .ExternFuncs }}
	if ($fname == "{{$entry.Name}}")
		return {{$entry.Size}}
	{{ end }}

	print(text("invalid extern func {}", $fname))
	@aeon_fatal()

function @aeon_call_extern($fname:text, $size:number)
	var $sp = $aeon_reg.1
	{{ range $entry := .ExternFuncs }}
	if ($fname == "{{$entry.Name}}")
		{{if $entry.HasReturn}}@aeon_mem_store($aeon_reg.1 - $size, {{end}}@{{$entry.Name}}({{range $i, $t := $entry.ArgTypes}}{{if $i }},{{end}}{{$t.Prefix}}@aeon_mem_load($sp-{{len $entry.ArgTypes}}+{{$i}}){{$t.Suffix}}{{end}}){{if $entry.HasReturn}}){{end}}
	{{ end }}

; Main Loop

function @aeon_run($pc:number):number
	@aeon_reg_init()
	$aeon_reg.0 = $pc
	$aeon_reg.1 = {{.GlobalSize}}

	var $size = 0

	repeat {{.NumRegisters}} ($reg)
		if ($reg == 0)
			continue
		@aeon_mem_store($aeon_reg.1, 0)
		$aeon_reg.1 += 1
	$aeon_reg.2 = $aeon_reg.1 - 1

	var $i = 0

	while ($i < 100000)
		$i++

		var $code = @aeon_code($aeon_reg.0)
		$aeon_ops.from($code, "{{.OPSep}}")
		$aeon_reg.0++
		{{if .Debug}}@debug(text("{} {} {} {} {} {}", delta(), $i, $aeon_reg.0, $aeon_reg.1, $aeon_reg.2, $code)){{end}}

		if ($aeon_ops.0 == "mov")
			$size = $aeon_ops.3:number
			if ($size == 1)
				@aeon_store($aeon_ops.1, @aeon_load($aeon_ops.2))
			elseif (last($aeon_ops.2) == "@")
				@aeon_mov_size($aeon_ops.1, $aeon_ops.2, $size)
			else
				@aeon_mov_init($aeon_ops.1, $aeon_ops.2, $size)
		elseif ($aeon_ops.0 == "bop")
			@aeon_store($aeon_ops.1, @aeon_bop($aeon_ops.2:number, $aeon_ops.3, $aeon_ops.4, $aeon_ops.5))
		elseif ($aeon_ops.0 == "uop")
			@aeon_store($aeon_ops.1, @aeon_uop($aeon_ops.2, $aeon_ops.3))
		elseif ($aeon_ops.0 == "jmp")
			if (@aeon_load($aeon_ops.1))
				$aeon_reg.0 = @aeon_load($aeon_ops.2)
		elseif ($aeon_ops.0 == "cal")
			var $fhdr = @aeon_load($aeon_ops.1)
			var $ftype = @aeon_mem_load($fhdr + 0)
			if ($ftype == 0)
				@__builtin_panic("tried to call nil function")
			elseif ($ftype == 1)
				var $fname = @aeon_str_load(@aeon_mem_load($fhdr + 3))
			 	{{if .Debug}}@debug(text("extern {}", $fname)){{end}}
				$size = @aeon_call_size($fname)
				@aeon_call_extern($fname, $size)
				$aeon_reg.1 -= $size
			elseif ($ftype == 2)
				var $faddr = @aeon_mem_load($fhdr + 3)
				repeat {{.NumRegisters}} ($reg)
					@aeon_mem_store($aeon_reg.1 + {{.NumRegisters}} - $reg - 1, $aeon_reg.$reg)

				$aeon_reg.1 += {{.NumRegisters}}
				$aeon_reg.2 = $aeon_reg.1 - 1
				$aeon_reg.0 = $faddr
			else
				print(text("panic: unrecognized call function type: {}", $ftype))
				@aeon_fatal()
		elseif ($aeon_ops.0 == "ret")
			var $fp = $aeon_reg.2
			repeat {{$.NumRegisters}} ($reg)
				$aeon_reg.$reg = @aeon_mem_load($fp-$reg)

			$aeon_reg.1 = $aeon_reg.1 - $aeon_ops.1:number

			if ($aeon_reg.0 == 0) {
				return
			}
		elseif ($aeon_ops.0 == "str")
			var $str = ""
			if ($aeon_ops.size == 3)
				$str = $aeon_ops.2
			@aeon_store($aeon_ops.1, @aeon_str_alloc($str))
		elseif ($aeon_ops.0 == "alc")
			@aeon_store($aeon_ops.1, @aeon_heap_alloc(@aeon_load($aeon_ops.2)))
		elseif ($aeon_ops.0 == "app")
			var $dstSlice = @aeon_load_addr($aeon_ops.1)
			var $srcSlice = @aeon_load_addr($aeon_ops.2)
			$size = $aeon_ops.4:number
			var $elem = 0
			if $size == 1
				$elem = @aeon_load($aeon_ops.3)
			else
				$elem = @aeon_load_addr($aeon_ops.3)
			@aeon_append(@aeon_mem_load($srcSlice), @aeon_mem_load($srcSlice + 1), @aeon_mem_load($srcSlice + 2), $elem, $size, $srcSlice)
		elseif ($aeon_ops.0 == "nop")
			continue
		else
			@__builtin_panic(text("unrecognized bytecode {}", $code))
	@__builtin_panic(text("exceeded execution limit"))

init
	@aeon_reg_init()
	@aeon_code_init()
	@aeon_mem_init()
	@aeon_str_init()
	@aeon_heap_init()
{{range $addr := .VarInitFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}
{{range $addr := .InitFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}

tick
{{range $addr := .UpdateFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}
