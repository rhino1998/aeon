

function @print($s:text)
	print($s)

function @add($a:number, $b:number):number
	return $a + $b


const $PAGE_SIZE = {{.PageSize}}

{{range $page := loop 0 .NumCodePages -}}
array $aeon_code_page_{{$page}}_c:text
{{end}}
{{range $page := loop 0 .NumMemPages -}}
array $aeon_mem_page_{{$page}}_c:text
{{end}}
array $aeon_reg:text

function @aeon_fatal()
	var $x = "hello"
	$x = $x:number

function @aeon_trunc($a:number):number
	if ($a > 0)
		return floor($a)
	return ceil($a)

function @aeon_code_init()
	{{range $page := loop 0 .NumCodePages}}$aeon_code_page_{{$page}}_c.fill(65535, ""){{"\n\t"}}{{end}}
	{{range $addr, $bc := .Code}}$aeon_code_page_{{$addr.Page}}_c.{{$addr.Addr}} = "{{$bc}}"{{"\n\t"}}{{end}}

function @aeon_code($addr:number):text
	var $page = @aeon_trunc($addr / $PAGE_SIZE)
	var $pageAddr = @aeon_trunc($addr % $PAGE_SIZE)
	{{range $page := loop 0 .NumCodePages}}
	if ($page == {{$page}})
		return $aeon_code_page_{{$page}}_c.$pageAddr
	{{ end }}

function @aeon_reg_init()
	$aeon_reg.fill({{.NumRegisters}}, "")

function @aeon_reg_load($reg:number):text
	return $aeon_reg.$reg

function @aeon_reg_store($reg:number, $v:text):text
	$aeon_reg.$reg = $v

function @aeon_mem_load($addr:number):text
	var $page = @aeon_trunc($addr / $PAGE_SIZE)
	var $pageAddr = @aeon_trunc($addr % $PAGE_SIZE)
	{{range $page := loop 0 .NumMemPages}}
	if ($page == {{$page}})
		return $aeon_mem_page_{{$page}}_c.$pageAddr
	{{end}}

function @aeon_mem_store($addr:number, $v:text):text
	var $page = @aeon_trunc($addr / $PAGE_SIZE)
	var $pageAddr = @aeon_trunc($addr % $PAGE_SIZE)

	{{range $page := loop 0 .NumMemPages}}
	if ($page == {{$page}})
		$aeon_mem_page_{{$page}}_c.$pageAddr = $v
	{{end}}

function @aeon_mem_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_mem_page_{{$page}}_c.fill($PAGE_SIZE, ""){{"\n\t"}}{{end}}

recursive function @aeon_load($op:text):text
	if ($op.k == "I")
		return $op.v
	elseif ($op.k == "R")
		return @aeon_reg_load($op.v:number)
	elseif ($op.k == "*")
		var $indirect = $op.v
		return @aeon_mem_load(recurse($indirect.p):number)
	elseif ($op.k == "*")
		var $offset = $op.v
		return recurse($offset.a):number + recurse($offset.b):number
	else
		print(text("bad operand for load {}", $op))
		@aeon_fatal()

function @aeon_store($op:text, $v:text)
	if ($op.s == "R")
		@aeon_reg_store($op.v:number, $v)
	elseif ($op.s == "*")
		var $indirect = $op.v
		@aeon_mem_store(@aeon_load($indirect.p), $v)
	else
		print(text("bad operand for store {}", $op))
		@aeon_fatal()

function @aeon_pow_int($a:text, $b:text):text
	return pow(@aeon_trunc($a:number), @aeon_trunc($b:number)):text

function @aeon_pow_float($a:text, $b:text):text
	return pow($a:number, $b:number):text

function @aeon_add_int($a:text, $b:text):text
	return (@aeon_trunc($a:number) + @aeon_trunc($b:number)):text

function @aeon_add_float($a:text, $b:text):text
	return ($a:number + $b:number):text

function @aeon_add_string($a:text, $b:text):text
	return $a & $b

function @aeon_sub_int($a:text, $b:text):text
	return (@aeon_trunc($a:number) - @aeon_trunc($b:number)):text

function @aeon_sub_float($a:text, $b:text):text
	return ($a:number - $b:number):text

function @aeon_mul_int($a:text, $b:text):text
	return (@aeon_trunc($a:number) * @aeon_trunc($b:number)):text

function @aeon_mul_float($a:text, $b:text):text
	return ($a:number * $b:number)):text

function @aeon_div_int($a:text, $b:text):text
	return (@aeon_trunc($a:number) * @aeon_trunc($b:number)):text

function @aeon_div_float($a:text, $b:text):text
	return ($a:number * $b:number):text

function @aeon_mod_int($a:text, $b:text):text
	return (@aeon_trunc($a:number) % @aeon_trunc($b:number)):text

function @aeon_lt($a:text, $b:text):text
	return ($a:number < $b:number):text

function @aeon_gt($a:text, $b:text):text
	return ($a:number > $b:number):text

function @aeon_lte($a:text, $b:text):text
	return ($a:number < $b:number):text

function @aeon_gte($a:text, $b:text):text
	return ($a:number > $b:number):text

function @aeon_eq($a:text, $b:text):text
	return ($a:number == $b:number):text

function @aeon_ne($a:text, $b:text):text
	return ($a:number == $b:number):text

function @aeon_extern_args($bc:text):number
	{{ range $entry := .ExternFuncs }}
	if ($bc.f == "{{$entry.Name}}")
		return {{len $entry.ArgTypes}}
	{{ end }}

function @aeon_call_extern($bc:text, $sp:number):text
	{{ range $entry := .ExternFuncs }}
	if ($bc.f == "{{$entry.Name}}")
		{{if $entry.HasReturn}}return{{end}} @{{$entry.Name}}({{range $i, $t := $entry.ArgTypes}}{{if $i }},{{end}}@aeon_mem_load($sp-{{len $entry.ArgTypes}}+{{$i}}){{$t}}{{end}})
	{{ end }}

function @aeon_bop($op:text, $a:text, $b:text):text
	var $av = @aeon_load($a)
	var $bv = @aeon_load($b)

	if ($op == "I+I")
		return @aeon_add_int($av, $bv)
	elseif ($op == "F+F")
		return @aeon_add_float($av, $bv)
	elseif ($op == "S+S")
		return @aeon_add_string($av, $bv)
	elseif ($op == "I-I")
		return @aeon_sub_int($av, $bv)
	elseif ($op == "F-F")
		return @aeon_sub_float($av, $bv)
	elseif ($op == "I*I")
		return @aeon_mul_int($av, $bv)
	elseif ($op == "F*F")
		return @aeon_mul_float($av, $bv)
	elseif ($op == "I/I")
		return @aeon_div_int($av, $bv)
	elseif ($op == "F/F")
		return @aeon_div_float($av, $bv)
	elseif ($op == "I%I")
		return @aeon_mod_int($av, $bv)
	elseif ($op == "I**I")
		return @aeon_pow_int($av, $bv)
	elseif ($op == "F**F")
		return @aeon_pow_float($av, $bv)
	elseif ($op == "I<I")
		return @aeon_lt($av, $bv)
	elseif ($op == "I>I")
		return @aeon_gt($av, $bv)
	elseif ($op == "F<F")
		return @aeon_lt($av, $bv)
	elseif ($op == "F>F")
		return @aeon_gt($av, $bv)
	elseif ($op == "I<=I")
		return @aeon_lte($av, $bv)
	elseif ($op == "I>=I")
		return @aeon_gte($av, $bv)
	elseif ($op == "F<=F")
		return @aeon_lte($av, $bv)
	elseif ($op == "F>=F")
		return @aeon_gte($av, $bv)
	elseif ($op == "I==I")
		return @aeon_eq($av, $bv)
	elseif ($op == "F==F")
		return @aeon_eq($av, $bv)
	elseif ($op == "S==S")
		return @aeon_eq($av, $bv)
	elseif ($op == "B==B")
		return @aeon_eq($av, $bv)
	elseif ($op == "I!=I")
		return @aeon_ne($av, $bv)
	elseif ($op == "F!=F")
		return @aeon_ne($av, $bv)
	elseif ($op == "S!=S")
		return @aeon_ne($av, $bv)
	elseif ($op == "B!=B")
		return @aeon_ne($av, $bv)
	else
		print(text("bad binary operand {} {} {}", $op, $a, $b))
		@aeon_fatal()

function @aeon_run($pc:number):text
	var $sp = 0

	repeat 15 ($i)
		@aeon_mem_store($i, "")
		$sp++

	@aeon_mem_store($sp, "0")
	$sp++
	@aeon_mem_store($sp, "0")
	$sp++
	@aeon_mem_store($sp, "0")
	$sp++

	var $fp = $sp - 1

	var $i = 0

	while ($i < 5000)
		$i++

		var $bc = @aeon_code($pc)
		$pc++
		;print(text("{} {} {}", $i, $pc, $bc))

		if ($bc.t == "nop")
			continue
		elseif ($bc.t == "push")
			@aeon_mem_store($sp, @aeon_load($bc.s))
			$sp++
		elseif ($bc.t == "bop")
			@aeon_store($bc.d, $fp, @aeon_bop($bc.o, $bc.l, $bc.r))
		elseif ($bc.t == "mov")
			@aeon_store($bc.d, $fp, @aeon_load($bc.s))
		elseif ($bc.t == "jmp")
			$pc = @aeon_load($bc.s, $fp):number
		elseif ($bc.t == "jmpr")
			$pc += @aeon_load($bc.d, $fp):number
		elseif ($bc.t == "jmprc")
			var $cond = @aeon_load($bc.s, $fp):number
			if ($cond xor ($bc.i:number))
				$pc += @aeon_load($bc.d, $fp):number
		elseif ($bc.t == "popn")
			$sp -= @aeon_load($bc.s, $fp):number
		elseif ($bc.t == "ext")
			@aeon_call_extern($bc, $sp)
		elseif ($bc.t == "call")
			foreach $aeon_reg ($reg, $val)
				if $reg != 0
					@aeon_mem_store($sp, $val)
					$sp++

			var $funcAddr = @aeon_load($bc.f, $fp)
			@aeon_mem_store($sp, $sp:text)
			$sp++
			@aeon_mem_store($sp, $fp:text)
			$sp++
			@aeon_mem_store($sp, $pc:text)
			$sp++

			$fp = $sp-1
			$pc = $funcAddr
		elseif ($bc.t == "ret")
			foreach $aeon_reg ($reg, $val)
				if $reg != 0
					@aeon_reg_store($reg, @aeon_mem_load($fp-3-($reg-2)))
			$pc = @aeon_mem_load($fp):number
			$sp = @aeon_mem_load($fp - 2):number
			$fp = @aeon_mem_load($fp - 1):number
			if ($fp == 0)
				return @aeon_reg_load(0)
		else
			print("fail", $bc)
			@aeon_fatal()
			return

init
	@aeon_reg_init()
	@aeon_code_init()
	@aeon_mem_init()
	print(@aeon_run({{.MainFunc}}))
	print("hello")
