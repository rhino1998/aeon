
; Utilities

function @aeon_fatal()
	var $x = "hello"
	$x = $x:number

function @debug($s:text)
	print("debug: " & $s)

function @__builtin_panic($s:text)
	var $msg = "panic: " & $s
	{{if .Debug}}@debug($msg){{end}}
	print($msg)
	@aeon_fatal()

function @__builtin_assert($cond:number, $msg:text)
	if !($cond)
		print(text("assertion failed: {}", $msg))
		@aeon_fatal()

function @aeon_trunc($a:number):number
	if ($a > 0)
		return floor($a)
	return ceil($a)

function @__builtin_sin($n:number):number
	return sin($n)

function @__builtin_cos($n:number):number
	return cos($n)

function @print($s:text)
	print($s)

; Memory Layout
const $PAGE_SIZE = {{.PageSize}}

{{range $page := loop 0 .NumCodePages -}}
array $aeon_code_page_{{$page}}:text
{{end}}
{{range $page := loop 0 .NumMemPages -}}
array $aeon_mem_page_{{$page}}:number
{{end}}
{{range $page := loop 0 .NumStrPages -}}
array $aeon_str_page_{{$page}}:text
{{end}}
var $aeon_str_index = 0
array $aeon_reg:number

function @aeon_code_init()
	{{range $page := loop 0 .NumCodePages}}$aeon_code_page_{{$page}}.fill($PAGE_SIZE, ""){{"\n\t"}}{{end}}
	{{range $addr, $bc := .Code}}$aeon_code_page_{{$addr.Page}}.{{$addr.Addr}} = "{{$bc}}"{{"\n\t"}}{{end}}

function @aeon_code($addr:number):text
	var $page = @aeon_trunc($addr / $PAGE_SIZE)
	var $pageAddr = @aeon_trunc($addr % $PAGE_SIZE)
	{{range $page := loop 0 .NumCodePages}}
	if ($page == {{$page}})
		return $aeon_code_page_{{$page}}.$pageAddr
	{{ end }}

function @aeon_reg_load($reg:number):number
	return $aeon_reg.$reg

function @aeon_reg_store($reg:number, $v:number)
	$aeon_reg.$reg = $v

function @aeon_reg_init()
	$aeon_reg.fill({{.NumRegisters}}, 0)

function @aeon_mem_load($addr:number):number
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 0 .NumMemPages}}
	if ($page == {{$page}})
		return $aeon_mem_page_{{$page}}.$pageAddr
	{{end}}

function @aeon_mem_store($addr:number, $v:number):text
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE

	{{range $page := loop 0 .NumMemPages}}
	if ($page == {{$page}})
		$aeon_mem_page_{{$page}}.$pageAddr = $v
	{{end}}

function @aeon_mem_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_mem_page_{{$page}}.fill($PAGE_SIZE, 0){{"\n\t"}}{{end}}

function @aeon_str_load($addr:number):text
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE
	{{range $page := loop 0 .NumStrPages}}
	if ($page == {{$page}})
		return $aeon_str_page_{{$page}}.$pageAddr
	{{end}}

function @aeon_str_store($addr:number, $v:text):text
	var $page = floor($addr / $PAGE_SIZE)
	var $pageAddr = $addr % $PAGE_SIZE

	{{range $page := loop 0 .NumStrPages}}
	if ($page == {{$page}})
		$aeon_str_page_{{$page}}.$pageAddr = $v
	{{end}}

function @aeon_str_init()
	{{range $page := loop 0 .NumMemPages}}$aeon_str_page_{{$page}}.fill($PAGE_SIZE, ""){{"\n\t"}}{{end}}
	{{range $i, $str := .Strings }}@aeon_str_store({{$i}}, "{{$str}}"){{"\n\t"}}{{end}}
	$aeon_str_index = {{len .Strings}}

function @aeon_str_alloc($v:text):number
	$aeon_str_index++
	@aeon_str_store($aeon_str_index, $v)
	return $aeon_str_index

function @aeon_vtable($type:number, $name:text):number
	{{range $type, $typeTable := .VTable}}if ($type == {{$type}}){{"\n\t\t"}}{{range $name, $addr := $typeTable}}if ($name == "{{$name}}"){{"\n\t\t\t"}}return {{$addr}}{{"\n\t\t"}}{{end}}{{"\n\t"}}{{end}}

; Heap
var $aeon_heap_start:number
var $aeon_heap_index:number

function @aeon_heap_init()
	$aeon_heap_start = @aeon_trunc({{.NumMemPages}} * {{.PageSize}} / 2)
	$aeon_heap_index = $aeon_heap_start

function @aeon_heap_alloc($size:number):number
	var $addr = $aeon_heap_index
	$aeon_heap_index += $size

	; TODO: bounds checking
	return $addr

; Operand Evaluation
array $aeon_ops:text
array $aeon_op_uops:text
array $aeon_op_arg_stack:number

function @aeon_load_internal():number
	foreach $aeon_op_uops ($_, $uop)
		var $k = substring($uop, 0, 1)
		var $k2 = ""
		if (size($uop) > 1)
			$k2 = substring($uop, 0, 2)
		var $arg1 = 0
		var $arg2 = 0
		if ($k == "I")
			$aeon_op_arg_stack.append(substring($uop, 1, size($uop.size)):number)
		elseif ($k == "R")
			$aeon_op_arg_stack.append(@aeon_reg_load(substring($uop, 1, size($uop) - 1):number))
		elseif ($k == "@")
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(@aeon_mem_load($arg1))
		elseif ($k == "+")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 + $arg2)
		elseif ($k == "*")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 * $arg2)
		elseif ($k2 == "==")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 == $arg2)
		elseif ($k2 == "!=")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 != $arg2)
		elseif ($k2 == "<=")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 <= $arg2)
		elseif ($k == "<")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 < $arg2)
		elseif ($k == "-")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append($arg1 - $arg2)
		elseif ($k == "!")
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(!$arg1)
		elseif ($k == "V")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$aeon_op_arg_stack.append(@aeon_vtable($arg1, @aeon_str_load($arg2)))
		elseif ($k == "#")
			$arg2 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			$arg1 = $aeon_op_arg_stack.last
			$aeon_op_arg_stack.pop()
			if ($arg1 >= $arg2)
				print(text("index out of bounds: {} {}", $arg1, $arg2))
				@aeon_fatal()
			$aeon_op_arg_stack.append($arg1)
		else
			print(text("bad uop in load {}", $uop))
			@aeon_fatal()

	var $ret = $aeon_op_arg_stack.0
	$aeon_op_arg_stack.clear()
	return $ret

function @aeon_load($op:text):number
	$aeon_op_uops.from($op, "{{.UOPSep}}")
	return @aeon_load_internal()

function @aeon_load_addr($op:text):number
	$aeon_op_uops.from($op, "{{.UOPSep}}")
	var $uop = $aeon_op_uops.last
	$aeon_op_uops.pop()
	if ($uop == "@")
		return @aeon_load_internal()
	else
		return @aeon_load_internal()

function @aeon_mov_size($dst:text, $src:text, $size:number)
	var $dstAddr = @aeon_load_addr($dst)
	var $srcAddr = @aeon_load_addr($src)

	repeat $size ($offset)
		@aeon_mem_store($dstAddr+$offset, @aeon_mem_load($srcAddr+$offset))

function @aeon_mov_init($dst:text, $src:text, $size:number)
	var $dstAddr = @aeon_load_addr($dst)
	var $srcVal = @aeon_load($src)

	repeat $size ($offset)
		@aeon_mem_store($dstAddr+$offset, $srcVal)


function @aeon_load_field($op:text, $offset:number):number
	return @aeon_mem_load(@aeon_load($op) + $offset)

function @aeon_store($op:text, $v:number)
	$aeon_op_uops.from($op, "{{.UOPSep}}")
	var $uop = $aeon_op_uops.last
	$aeon_op_uops.pop()
	if (substring($uop, 0, 1) == "R")
		@aeon_reg_store(substring($uop, 1, $uop.size-1):number, $v)
	elseif ($uop == "@")
		@aeon_mem_store(@aeon_load_internal(), $v)
	else
		print(text("bad operand for store {}", $uop))
		@aeon_fatal()

function @aeon_add_string($a:number, $b:number):number
	return @aeon_str_alloc(@aeon_str_load($a) & @aeon_str_load($b))

function @aeon_eq_string($a:number, $b:number):number
	return (@aeon_str_load($a) == @aeon_str_load($b))

function @aeon_ne_string($a:number, $b:number):number
	return (@aeon_str_load($a) != @aeon_str_load($b))

function @itoa($n:number):number
	return @aeon_str_alloc($n:text)

function @aeon_call_size($fname:text):number
	var $sp = $aeon_reg.1
	{{ range $entry := .ExternFuncs }}
	if ($fname == "{{$entry.Name}}")
		return {{$entry.Size}}
	{{ end }}

	print(text("invalid extern func {}", $fname))
	@aeon_fatal()

function @aeon_call_extern($fname:text, $size:number)
	var $sp = $aeon_reg.1
	{{ range $entry := .ExternFuncs }}
	if ($fname == "{{$entry.Name}}")
		{{if $entry.HasReturn}}@aeon_mem_store($aeon_reg.1 - $size, {{end}}@{{$entry.Name}}({{range $i, $t := $entry.ArgTypes}}{{if $i }},{{end}}{{$t.Prefix}}@aeon_mem_load($sp-{{len $entry.ArgTypes}}+{{$i}}){{$t.Suffix}}{{end}}){{if $entry.HasReturn}}){{end}}
	{{ end }}

function @aeon_bop($op:text, $a:text, $b:text):number
	var $av = @aeon_load($a)
	var $bv = @aeon_load($b)

	if ($op == "I+I")
		return $av + $bv
	elseif ($op == "F+F")
		return $av + $bv
	elseif ($op == "S+S")
		return @aeon_add_string($av, $bv)
	elseif ($op == "I-I")
		return $av - $bv
	elseif ($op == "F-F")
		return $av - $bv
	elseif ($op == "I*I")
		return $av * $bv
	elseif ($op == "F*F")
		return $av * $bv
	elseif ($op == "I/I")
		return @aeon_trunc($av / $bv)
	elseif ($op == "F/F")
		return $av / $bv
	elseif ($op == "I%I")
		return $av % $bv
	elseif ($op == "I**I")
		return pow($av, $bv)
	elseif ($op == "F**F")
		return pow($av, $bv)
	elseif ($op == "I<I")
		return $av < $bv
	elseif ($op == "I>I")
		return $av > $bv
	elseif ($op == "F<F")
		return $av < $bv
	elseif ($op == "F>F")
		return $av > $bv
	elseif ($op == "I<=I")
		return $av <= $bv
	elseif ($op == "I>=I")
		return $av >= $bv
	elseif ($op == "F<=F")
		return $av <= $bv
	elseif ($op == "F>=F")
		return $av >= $bv
	elseif ($op == "I==I")
		return $av == $bv
	elseif ($op == "F==F")
		return $av == $bv
	elseif ($op == "S==S")
		return @aeon_eq_string($av, $bv)
	elseif ($op == "B==B")
		return $av == $bv
	elseif ($op == "I!=I")
		return $av != $bv
	elseif ($op == "F!=F")
		return $av != $bv
	elseif ($op == "S!=S")
		return @aeon_ne_string($av, $bv)
	elseif ($op == "B!=B")
		return $av != $bv
	else
		print(text("bad binary operand {} {} {}", $op, $a, $b))
		@aeon_fatal()

function @aeon_uop($op:text, $a:text):number
	var $av = @aeon_load($a)

	if ($op == "-I")
		return -$av
	elseif ($op == "-F")
		return -$av
	elseif ($op == "+I")
		return +$av
	elseif ($op == "+F")
		return +$av
	else
		print(text("bad unary operand {} {} {}", $op, $a))
		@aeon_fatal()

function @aeon_run($pc:number):number
	@aeon_reg_init()
	$aeon_reg.0 = $pc
	$aeon_reg.1 = {{.GlobalSize}}
	repeat {{.NumRegisters}} ($reg)
		if ($reg == 0)
			continue
		@aeon_mem_store($aeon_reg.1, 0)
		$aeon_reg.1 += 1
	$aeon_reg.2 = $aeon_reg.1 - 1

	var $i = 0

	while ($i < 100000)
		$i++

		var $code = @aeon_code($aeon_reg.0)
		$aeon_ops.from($code, "{{.OPSep}}")
		$aeon_reg.0++
		{{if .Debug}}@debug(text("{} {} {} {} {} {}", delta(), $i, $aeon_reg.0, $aeon_reg.1, $aeon_reg.2, $code)){{end}}

		if ($aeon_ops.0 == "mov")
			var $size = $aeon_ops.3:number
			if ($size == 1)
				@aeon_store($aeon_ops.1, @aeon_load($aeon_ops.2))
			elseif (last($aeon_ops.2) == "@")
				@aeon_mov_size($aeon_ops.1, $aeon_ops.2, $size)
			else
				@aeon_mov_init($aeon_ops.1, $aeon_ops.2, $size)
		elseif ($aeon_ops.0 == "bop")
			@aeon_store($aeon_ops.1, @aeon_bop($aeon_ops.2, $aeon_ops.3, $aeon_ops.4))
		elseif ($aeon_ops.0 == "uop")
			@aeon_store($aeon_ops.1, @aeon_uop($aeon_ops.2, $aeon_ops.3))
		elseif ($aeon_ops.0 == "jmp")
			if (@aeon_load($aeon_ops.1))
				$aeon_reg.0 = @aeon_load($aeon_ops.2)
		elseif ($aeon_ops.0 == "cal")
			var $fhdr = @aeon_load($aeon_ops.1)
			var $ftype = @aeon_mem_load($fhdr + 0)
			if ($ftype == 0)
				@__builtin_panic("tried to call nil function")
			elseif ($ftype == 1)
				var $fname = @aeon_str_load(@aeon_mem_load($fhdr + 3))
			 	{{if .Debug}}@debug(text("extern {}", $fname)){{end}}
				var $fsize = @aeon_call_size($fname)
				@aeon_call_extern($fname, $fsize)
				$aeon_reg.1 -= $fsize
			elseif ($ftype == 2)
				var $faddr = @aeon_mem_load($fhdr + 3)
				repeat {{.NumRegisters}} ($reg)
					@aeon_mem_store($aeon_reg.1 + {{.NumRegisters}} - $reg - 1, $aeon_reg.$reg)

				$aeon_reg.1 += {{.NumRegisters}}
				$aeon_reg.2 = $aeon_reg.1 - 1
				$aeon_reg.0 = $faddr
			else
				print(text("panic: unrecognized call function type: {}", $ftype))
				@aeon_fatal()
		elseif ($aeon_ops.0 == "ret")
			var $fp = $aeon_reg.2
			repeat {{$.NumRegisters}} ($reg)
				$aeon_reg.$reg = @aeon_mem_load($fp-$reg)

			$aeon_reg.1 = $aeon_reg.1 - $aeon_ops.1:number

			if ($aeon_reg.0 == 0) {
				return
			}
		elseif ($aeon_ops.0 == "str")
			var $str = ""
			if ($aeon_ops.size == 3)
				$str = $aeon_ops.2
			@aeon_store($aeon_ops.1, @aeon_str_alloc($str))
		elseif ($aeon_ops.0 == "alc")
			@aeon_store($aeon_ops.1, @aeon_heap_alloc($aeon_ops.2:number))
		elseif ($aeon_ops.0 == "nop")
			continue
		else
			@__builtin_panic(text("unrecognized bytecode {}", $code))
	@__builtin_panic(text("exceeded execution limit"))

init
	@aeon_reg_init()
	@aeon_code_init()
	@aeon_mem_init()
	@aeon_str_init()
	@aeon_heap_init()
{{range $addr := .VarInitFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}
{{range $addr := .InitFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}

tick
{{range $addr := .UpdateFuncs}}{{"\t"}}@aeon_run({{$addr}}){{"\n"}}{{end}}
